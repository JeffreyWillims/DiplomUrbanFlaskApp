from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from os import path
from flask_login import LoginManager

"""
1. Flask: Импортируется класс Flask, который используется для создания основного объекта приложения Flask.
2. SQLAlchemy: Импортируется класс SQLAlchemy, который предоставляет интерфейс для работы с базами данных через ORM (Object Relational Mapping).
3. os.path: Импортируется модуль path из пакета os, который содержит функции для работы с путями к файлам и директориям.
4. LoginManager: Импортируется класс LoginManager из модуля flask_login, который помогает управлять сессиями пользователей и аутентификацией.

"""

db = SQLAlchemy()
DB_NAME = "database.db"

"""
Создается экземпляр класса SQLAlchemy, который будет использоваться для взаимодействия с базой данных 
через ORM (Object Relational Mapping). Этот объект позволяет создавать модели, выполнять запросы и управлять миграциями базы данных.
Переменная DB_NAME хранит имя файла базы данных, которое будет использовано для подключения к базе данных SQLite. 
В данном случае база данных называется database.db.
"""
def create_app():
    app = Flask(__name__, template_folder='templates')
    app.config['SECRET_KEY'] = 'Jeffrey Willims'
    app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{DB_NAME}'
    db.init_app(app)
    """
    Функция create_app создает и настраивает экземпляр приложения Flask.
    Здесь создается объект приложения Flask. Аргумент __name__ указывает на имя текущего модуля, 
    а параметр template_folder определяет директорию, где будут находиться HTML-шаблоны.
    
    Устанавливается секретный ключ, который необходим для защиты данных сессии и предотвращения атак CSRF 
    (Cross-Site Request Forgery). Важно, чтобы значение секретного ключа было сложным и уникальным для каждого приложения.
    
    Строка конфигурации указывает URI базы данных, которую будет использовать SQLAlchemy. 
    В данном случае используется SQLite, и файл базы данных будет называться DB_NAME.
    
    Метод init_app связывает объект db (экземпляр SQLAlchemy) с текущим приложением Flask. 
    Это необходимо для того, чтобы SQLAlchemy мог корректно работать с вашим приложением.
    """
    from .views import views
    from .auth import auth

    app.register_blueprint(views, url_prefix='/')
    app.register_blueprint(auth, url_prefix='/')

    """
    В этом фрагменте кода происходит регистрация двух blueprints (views и auth) 
    в приложении Flask. Blueprint – это способ организации маршрутов и ресурсов в вашем приложении, позволяющий разделить их на отдельные модули.
    
     Здесь оба blueprint-а регистрируются в основном приложении Flask. Каждый blueprint получает префикс URL, который будет добавлен ко всем маршрутам внутри него. 
     В данном случае оба blueprint-а имеют пустой префикс /, что означает, что их маршруты будут доступны прямо с корневого URL-адреса.
    """

    from .models import User, Note

    with app.app_context():
        db.create_all()

    login_manager = LoginManager()
    login_manager.login_view = 'auth.login'
    login_manager.init_app(app)

    """
    Фрагмент кода выполняет несколько задач, связанных с настройкой базы данных и системой авторизации в приложении Flask. 
    Внутри блока with app.app_context(): вызывается метод db.create_all(), который создает все таблицы, соответствующие моделям, 
    зарегистрированным в объекте db (SQLAlchemy). Контекст приложения необходим для правильной работы с базой данных.
    Создается экземпляр класса LoginManager.
    Свойству login_view присваивается значение 'auth.login', что указывает на маршрут, куда будут перенаправляться пользователи, если они попытаются получить доступ к защищенным страницам без входа в систему.
    Менеджер логина инициализируется для приложения с помощью метода init_app(app).
    
    Здесь мы создали приложение Flask, настроили базу данных и менеджера логина, 
    а затем зарегистрировали blueprints views и auth. Теперь наше приложение готово к использованию системы авторизации и работы с моделями User и Note.
    """

    @login_manager.user_loader
    def load_user(id):
        return User.query.get(int(id))

    return app

"""
Этот фрагмент кода завершает функцию create_app и добавляет декоратор @login_manager.user_loader, который загружает пользователя по идентификатору. 
декоратор сообщает менеджеру логина (LoginManager), какую функцию следует вызывать для загрузки пользователя по его идентификатору. 
Это важно для поддержания состояния аутентификации между запросами.
функция принимает идентификатор пользователя (id) и использует метод get из ORM SQLAlchemy для получения записи пользователя из базы данных. 
Идентификатор преобразуется в целое число с помощью int(id) для совместимости с типом поля id в модели 
"""


def create_database(app):
    if not path.exists('website/' + DB_NAME):
        db.create_all()
        print('Created Database!')

"""
Эта функция create_database предназначена для проверки существования базы данных и ее создания, если она еще не существует.
Сначала проверяется наличие файла базы данных в папке website с именем, указанным в переменной DB_NAME. Если файл не найден, выполняется следующая часть кода.
Если база данных отсутствует, вызывается метод create_all() объекта db, который создает все необходимые таблицы в базе данных на основании зарегистрированных моделей.
После успешного создания базы данных выводится сообщение Created Database!.

"""

